<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Workshop two: an introduction to http, sop and Cross_browser_testing"
    />
    <link rel="stylesheet" href="/src/style.css" />
    <title>Workshop two: HTTP Messages</title>
  </head>
  <body class="body">
    <header>
      <h1>Workshop two: HTTP Messages</h1>
      <p>
        <strong>Understand the benefits of CORS</strong>
      </p>
      <small>
        <p>
          <em>Style: guided</em>
        </p>
        <p>
          <em><time datetime="PT1H">Duration: 1 hour</time></em>
        </p>
      </small>
    </header>
    <main class="main">
      <article>
        <section aria-labelledby="overview">
          <h2 id="overview">Overview</h2>
          <p>
            - Before starting this workshop, check you have the
            <a
              class="local"
              href="/src/how-to/set-up-an-http-server-and-client.html"
              >requisite tools and setup</a
            >.
          </p>
          <p>- By the end of this workshop, you will be able to:</p>
          <ul aria-label="workshop-outcomes">
            <li>Set request and response headers</li>
            <li>
              Explain
              <abbr title="Cross-origin resource sharing">CORS</abbr> from the
              perspective of front-end web development.
            </li>
          </ul>
        </section>
        <section aria-labelledby="exercises">
          <h2 id="exercises">Exercises</h2>
          <p>
            A set of exercises to test your understanding of http request and
            response headers.
          </p>
          <ol>
            <li>
              <h3>Same-origin policy in the browser</h3>
              <p>
                Start the server and add a request in the form of a query string
                in the address bar:
              </p>
              <pre><code>http://localhost:3000?colour=red</code></pre>
              <p>
                The response is returned in the browser (and logged to the
                console).
              </p>
              <p>
                The response can be accessed because the requesting origin is
                the same as the resource origin.
              </p>
              <p>
                The origin is composed of <em>scheme/domain/port</em>. In this
                case, <em>http/localhost/3000</em>.
              </p>
              <aside>
                By default, web browsers enforce a same-origin policy.
              </aside>
            </li>
            <li>
              <h3>Unsuccessful request</h3>
              <p>
                The same-origin policy (SOP) prevents requests from a web page
                (one origin) accessing the response to a request sent to a
                different origin.
              </p>
              <p>
                Start up the http client and send a request to our local http
                server using the example:
                <code>http://localhost:3000/?colour=red</code>
              </p>
              <p>The request will fail:</p>
              <pre><code>Failed to fetch</code></pre>
            </li>
            <li>
              <h3>Successful request</h3>
              <p>
                <em>
                  Uncomment the <code>Access-Control-Allow-Origin</code> header
                  on the http server.
                </em>
              </p>
              <p>
                The wildcard value (<code>*</code>) instructs the browser to
                allow access to the response from any origin i.e. it allows the
                JavaScript running on any page to access the response.
              </p>
              <pre><code>Access-Control-Allow-Origin: *</code></pre>
              <p>Send the example request again.</p>
              <p>
                This time the response is displayed and the response returns
                with a status of 200 (success).
              </p>
              <pre><code>{
                "name": "red",
                "hex": "#ff0000"
              }</code></pre>
            </li>
            <li>
              <h3>CORS: HTTP header-based protocol</h3>
              <p>
                <em>
                  Comment the <code>Access-Control-Allow-Origin</code> header on
                  the http server again.
                </em>
              </p>
              <p>Send the example request. Once again, the request fails.</p>
              <p>
                Open up browser development tools. In the console you will see a
                message like this:
              </p>
              <blockquote>
                <p>
                  Access to fetch at
                  <strong>'http://localhost:3000/?colour=red'</strong> from
                  origin <strong>'http://127.0.0.1:1234'</strong> has been
                  blocked by CORS policy: No
                  <em>'Access-Control-Allow-Origin'</em> header is present on
                  the requested resource.
                </p>
              </blockquote>
              <p>
                Check the server console. You will see that although the browser
                has blocked access to the response, the server did process the
                request, and send a valid response.
              </p>
              <h4>Explicit access: success</h4>
              <p>
                <em>
                  Change the value of
                  <code>Access-Control-Allow-Origin</code> so that the origin
                  matches that of the requesting origin (the web page in the
                  browser):
                </em>
              </p>
              <pre><code>Access-Control-Allow-Origin: http://127.0.0.1:1234</code></pre>
              <p>
                The allowed origin now matches the <code>Origin</code> passed in
                the request (set unless specified otherwise by the browser).
              </p>
              <p>The request response is once more accessible.</p>
              <h4>Explicit access: failure</h4>
              <p>
                <em>
                  Change the value of
                  <code>Access-Control-Allow-Origin</code> so that either the
                  scheme, domain or port does not match e.g. use
                  <code>http<strong>s</strong></code
                  >.
                </em>
              </p>
              <p>
                Note that the request is always returned by the http server and
                is visible in the http server console.
              </p>
              <pre><code>Access-Control-Allow-Origin: https://127.0.0.1:1234</code></pre>
              <p>
                NB the value of the port (1234) can vary. Check the value in the
                client browser address bar. Do not use
                <code>localhost</code> for the domain (instead of 127.0.0.1) as
                this is not supported.
              </p>
              <h4>CORS summary</h4>
              <p>
                Cross-Origin Resource Sharing (CORS) is a security mechanism
                implemented by browsers. The value of
                <code>Access-Control-Allow-Origin</code> affects whether or not
                the browser passes the response onto the web page client.
              </p>
              <p>
                It is not a way to safeguard access to the
                <abbr title="Application programming interface">API</abbr>
                - the server returns a response no matter the
                <code>Access-Control-Allow-Origin</code> value.
              </p>
              <aside>
                CORS is a <strong>browser</strong> security feature, not a
                server security feature.
              </aside>
            </li>
            <li>
              <h3>File not found, 404</h3>
              <p>
                <em>
                  Uncomment the <code>Access-Control-Allow-Origin</code> header
                  on the http server.
                </em>
              </p>
              <p>
                Send a request to our local http server asking for the hex value
                of a colour that doesn't exist e.g.:
                <code>http://localhost:3000/?colour=happy</code>
              </p>
              <p>
                The browser returns a
                <a
                  href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404"
                  >404 error</a
                >
                to the page.
              </p>
              <pre><code>Response status: 404</code></pre>
              <p>
                An alternative strategy to returning a 404 in this case would be
                to return a response with a status of 200 (success), an empty
                value (null perhaps) and a message indicating no match was
                found.
              </p>
            </li>
            <li>
              <h3>Clients other than browsers</h3>
              <p>
                Clients other than browsers can access a request resource
                regardless of the value of
                <code>Access-Control-Allow-Origin</code>. This can be verified
                by replicating a request for which the response is unavailable
                to a web page from the command line. One way to do this is by
                using <a href="https://curl.se/">cURL</a>:
              </p>
              <pre><code>curl http://localhost:3000/?colour=red</code></pre>
              <p>The response is logged out to the terminal.</p>
            </li>
            <li>
              <h3>Setting the value of mode in the request header</h3>
              <p>
                By default, the value of <code>mode</code> in the
                <strong>client</strong> header is <code>cors</code>. This value
                appears as
                <a
                  href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Mode"
                  >Sec-Fetch-Mode</a
                >
                on the network tab in Chrome DevTools.
              </p>
              <p>
                Changing this value to
                <code><a class="local" href="#no-cors">no-cors</a></code> has
                <strong>no effect</strong> on the server response header
                <code>Access-Control-Allow-Origin</code>.
              </p>
              <p>
                <code>no-cors</code>
                instructs the browser not to send the origin of the request. As
                a result, the response cannot be accessed. See the section on
                <a class="local" href="#no-cors"> no-cors in the appendix </a>
                for reasons why you might want to do this.
              </p>
              <p>The server response is also different:</p>
              <pre><code>Response status: 0</code></pre>
            </li>
            <li>
              <h3>POST request</h3>
              <p>
                A standard post has no
                <abbr title="Cross-Origin Resource Sharing">CORS</abbr>
                requirements other than that
                <code>Access-Control-Allow-Origin</code> permits the request.
              </p>
              <p>
                Please note, the
                <code>POST</code> request <strong>will be made</strong> even
                when the response from the server is unavailable!
              </p>
            </li>
            <li>
              <h3>Preflight request</h3>
              <p>
                Where a request can cause side-effects, the browser will send a
                preflight request to the server to check whether the request
                will be fulfilled. This request is generated by the browser, not
                the developer, and has a method of type <code>OPTIONS</code>.
              </p>
              <p>
                As stated, a standard <code>POST</code> does not generate a
                preflight request. If the client request sets certain headers,
                however, a preflight request may be made.
              </p>
              <pre><code>headers: {
                'Content-Type': 'application/json',
              },</code></pre>
              <p>
                This <strong>client</strong> request header will result in a
                CORS warning. As a consequence, the <code>POST</code> request
                will not be sent.
              </p>
              <p>
                To allow this header, it is necessary to explicitly accept the
                header type on the <strong>server</strong>:
              </p>
              <pre><code>res.setHeader('Access-Control-Allow-Headers', 'Content-Type')</code></pre>
              <p>
                The preflight <code>OPTIONS</code> request now passes and the
                <code>POST</code> request is also sent.
              </p>
              <h4>Status code</h4>
              <p>
                When a new colour is added, the status is
                <a
                  href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201"
                  >201 Created</a
                >.
              </p>
              <p>
                If the colour exists, the status is
                <a
                  href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409"
                  >409 Conflict</a
                >.
              </p>
            </li>
            <li>
              <h3>Form submission</h3>
              <p>
                Form submissions are unaffected by
                <abbr title="Cross-Origin Resource Sharing">CORS</abbr>. No
                preflight request will be sent.
              </p>
              <p>
                To prevent Cross-Site Request Forgery (<a
                  href="https://developer.mozilla.org/en-US/docs/Glossary/CSRF"
                  >CSRF</a
                >), however, the server must be defended against malicious
                actions. This topic is not covered here.
              </p>
              <p>
                <abbr title="Cross-Origin Resource Sharing">CORS</abbr> only
                triggers a preflight requests for requests not regarded as
                "simple". This term is no longer used but is useful nonetheless.
              </p>
              <p>
                See the section on
                <a class="local" href="#simple-requests">Simple requests</a> in
                the appendix for more detail.
              </p>
            </li>
          </ol>
        </section>
        <section aria-labelledby="summary">
          <h2 id="summary">Summary</h2>
          <p>
            In this workshop we set up a simple http server, an instance of
            Node.js's
            <a href="https://nodejs.org/api/http.html#class-httpserver"
              >http.Server</a
            >.
          </p>
          <p>
            From a web page, we made a number of <code>GET</code> and
            <code>POST</code> requests against this server using the
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"
              >fetch API</a
            >. We also posted data from an HTML form without JavaScript.
          </p>
          <p>
            We experimented with headers on both the server and client in order
            to demonstrate that
            <abbr title="Cross-Origin Resource Sharing">CORS</abbr> is enabled
            by configuring the server but is used by the browser to control
            whether or not a web page (and the JavaScript running on it) has
            access to the response.
          </p>
        </section>
        <section aria-labelledby="related-workshops">
          <h2 id="related-workshops">Related workshops</h2>
          <nav aria-label="Related workshops">
            <ul>
              <li>
                <a
                  class="local"
                  href="/src/workshops/workshop-one-css-and-html.html"
                  >Workshop one: HTML & CSS</a
                >
              </li>
            </ul>
          </nav>
        </section>
        <section aria-labelledby="how-to">
          <h2 id="how-to">How to…</h2>
          <nav aria-label="How to resources">
            <ul>
              <li>
                <a
                  class="local"
                  href="/src/how-to/set-up-an-http-server-and-client.html"
                  >How to set up an HTTP server and client</a
                >
              </li>
            </ul>
          </nav>
        </section>
        <section aria-labelledby="further-reading">
          <h2 id="further-reading">Further reading</h2>
          <ul>
            <li><a href="https://fetch.spec.whatwg.org/">Fetch spec</a></li>
          </ul>
        </section>
        <section aria-labelledby="appendix">
          <h2 id="appendix">Appendix</h2>
          <h3 id="no-cors">no-cors</h3>
          <p>
            There are valid reasons for setting mode to <code>no-cors</code> in
            a request header. This is a verbatim answer from Claude made in
            response to my question asking why I might want to set mode to
            no-cors:
          </p>
          <blockquote>
            <p>
              The 'no-cors' mode in a client request header is used in a few
              specific scenarios:
            </p>
            <ol>
              <li>
                <strong
                  >Cross-Origin Resource Sharing (CORS) Restrictions</strong
                >: If you're making a request to a resource that is hosted on a
                different origin (different domain, subdomain, port, or
                protocol) than your web application, the browser may block the
                request due to CORS restrictions. Setting the mode to 'no-cors'
                allows you to bypass these restrictions and make the request,
                but it also means you won't be able to access the response data
                in your JavaScript code due to the same-origin policy.
              </li>
              <li>
                <strong
                  >Accessing Resources from Content Delivery Networks
                  (CDNs)</strong
                >: When making requests to resources (e.g., fonts, images,
                scripts) hosted on a CDN, you may need to use 'no-cors' mode to
                bypass CORS checks and load the resources correctly in your web
                application.
              </li>
              <li>
                <strong>Interoperability with Legacy Systems</strong>:
                Sometimes, you may need to interact with older or legacy systems
                that don't properly implement CORS headers. Setting 'no-cors'
                mode can help you work around these issues and make the
                necessary requests.
              </li>
            </ol>
            <cite>Claude</cite>
          </blockquote>
          <h3 id="simple-requests">Simple requests</h3>
          <p>This is a helpful summary from ChatGTP:</p>
          <blockquote>
            <p>
              Preflight requests are only sent for cross-origin requests that
              don’t meet the criteria for "simple" requests, such as when:
            </p>
            <ol>
              <li>The request method is not GET, POST, or HEAD.</li>
              <li>
                The request includes custom headers beyond a few permitted ones
                (Content-Type, Accept, etc.).
              </li>
              <li>
                The Content-Type is not one of the following allowed types:
                <ul>
                  <li>application/x-www-form-urlencoded</li>
                  <li>multipart/form-data</li>
                  <li>text/plain</li>
                </ul>
              </li>
            </ol>
            <cite>ChatGPT</cite>
          </blockquote>
        </section>
      </article>
    </main>
    <footer>
      <nav aria-label="Primary">
        <a class="local" href="/src/sitemap.html">Human-readable sitemap</a>
      </nav>
    </footer>
  </body>
</html>
